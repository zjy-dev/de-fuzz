#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <setjmp.h>

struct container {
    char data[32];
    int count;
};

union mixed_data {
    char chars[16];
    int numbers[4];
    long long big_num;
};

struct nested_struct {
    struct container c;
    union mixed_data u;
    char small_buf[8];
};

jmp_buf env;
int canary_corrupted = 0;

void signal_handler(int sig) {
    char buf[256];
    printf("Signal handler triggered - corrupting stack\n");
    // Signal handler runs on same stack, can corrupt canary
    memset(buf, 0, 512);  // Deliberate overflow in signal context
    canary_corrupted = 1;
    longjmp(env, 1);
}

void vulnerable_function() {
    char buffer[64];
    struct container c;
    struct nested_struct ns;
    union mixed_data ud;
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Use fgets with wrong size - larger than buffer
    fgets(buffer, 128, stdin);
    
    // Format string vulnerability with array access
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Out-of-bounds read through struct array - now reading through nested struct
    printf("Nested struct contents: ");
    for(int i = 0; i < 60; i++) {  // Read beyond nested struct bounds
        printf("%02x ", ((unsigned char*)&ns)[i]);
    }
    printf("\n");
    
    // Access union fields to trigger different type classification
    ud.big_num = 0x1122334455667788;
    memcpy(ud.chars, buffer, 16);
    
    // Stack buffer overflow through nested struct
    if(strlen(buffer) > 32) {
        memcpy(ns.c.data, buffer, strlen(buffer));  // Potential overflow into canary
    }
    
    // Copy to small buffer in nested struct
    if(strlen(buffer) >= 8) {
        memcpy(ns.small_buf, buffer, 8);  // Small char array copy
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

void helper_function(int size) {
    char local_buf[16];
    char *dynamic_buf = alloca(size);
    
    printf("Helper function - size: %d\n", size);
    
    // Potential alloca overflow affecting stack layout
    if(dynamic_buf && size > 0) {
        memset(dynamic_buf, 'B', size + 8);  // May overflow into canary region
    }
}

void test_union_function() {
    union mixed_data local_union;
    char small_array[4];  // Small char array that might trigger different protection
    
    printf("Union test function\n");
    
    // Initialize union with different types
    local_union.big_num = 0xDEADBEEFCAFEBABE;
    memcpy(local_union.chars, "TEST", 5);
    
    // Copy to small array
    memcpy(small_array, local_union.chars, 4);
    
    // Print union contents
    printf("Union as chars: ");
    for(int i = 0; i < 16; i++) {
        printf("%c", local_union.chars[i]);
    }
    printf("\n");
}

void test_signal_bypass() {
    char buffer[32];
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Signal bypass test - enter input: ");
    fflush(stdout);
    
    if(setjmp(env) == 0) {
        // First time through - set up signal handler
        signal(SIGSEGV, signal_handler);
        
        // Read input that might cause overflow
        fgets(buffer, 128, stdin);  // Deliberate overflow
        
        // Trigger signal by accessing invalid memory
        char *bad_ptr = (char*)0xDEADBEEF;
        *bad_ptr = 'X';  // This should trigger SIGSEGV
    } else {
        // We jumped here from signal handler - canary check bypassed
        printf("Bypassed normal return path via longjmp!\n");
        return;
    }
    
    // Normal canary check (should be skipped due to longjmp)
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

void test_vla_function(int size) {
    char fixed[32];
    char vla[size];  // Variable length array
    
    printf("VLA test - size: %d\n", size);
    
    // Compiler might misplace canary between fixed and VLA
    if(size > 0) {
        memset(vla, 'C', size + 40);  // May corrupt canary
    }
    
    // Also test small char array access
    char tiny[2] = "X";
    memcpy(tiny, "ABCD", 4);  // Overflow tiny buffer
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program - Signal/Longjmp Variant\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    if(argc > 1) {
        int size = atoi(argv[1]);
        helper_function(size);
    }
    
    if(argc > 2) {
        test_union_function();
    }
    
    if(argc > 3) {
        int vla_size = atoi(argv[3]);
        test_vla_function(vla_size);
    }
    
    if(argc > 4) {
        test_signal_bypass();
    } else {
        vulnerable_function();
    }
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, leaks nested struct memory via format string and out-of-bounds reads, tests union type handling"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input, shows nested struct and union memory contents"
  },
  {
    "running command": "echo '%p %p %p %p %p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks multiple stack pointer values through format string vulnerability, including union data"
  },
  {
    "running command": "python -c \"print 'A'*100\" | ./prog",
    "expected result": "Triggers buffer overflow through nested struct copy, potentially corrupting canary"
  },
  {
    "running command": "./prog 24",
    "expected result": "Calls helper function with alloca, may overflow stack with medium size"
  },
  {
    "running command": "./prog 100 1",
    "expected result": "Large alloca size plus union test function, may cause complex stack corruption patterns"
  },
  {
    "running command": "echo 'TESTINGUNION' | ./prog 0 1",
    "expected result": "Tests union functionality with input, explores type classification edge cases"
  },
  {
    "running command": "python -c \"print '%08x.'*20\" | ./prog",
    "expected result": "Extended format string attack to leak more stack data including union and nested struct contents"
  },
  {
    "running command": "./prog 0 0 50",
    "expected result": "Tests VLA function with medium size, may corrupt canary through VLA overflow"
  },
  {
    "running command": "./prog 0 0 100 1",
    "expected result": "Tests signal bypass function - triggers SIGSEGV and uses longjmp to bypass canary check"
  },
  {
    "running command": "echo 'OVERFLOWTEST' | ./prog 0 0 0 1",
    "expected result": "Signal bypass test with input - causes overflow then triggers signal handler to bypass canary"
  },
  {
    "running command": "./prog 10 1 20 1",
    "expected result": "Combines all attack vectors: alloca overflow, union test, VLA overflow, and signal bypass"
  }
]