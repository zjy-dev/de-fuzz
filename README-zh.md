# DeFuzz

一个基于 LLM 约束求解的编译器防御策略模糊测试工具。

使用 Golang 编写。

## 核心思想

DeFuzz 灵感来自 HLPFuzz 论文。它使用 **LLM 驱动的渐进式约束求解** 来系统地探索编译器防御实现中难以触达的代码路径。

### 核心概念：基于 LLM 的约束求解

与传统覆盖率引导的模糊测试（随机变异）不同，DeFuzz 主动选择目标并引导 LLM 生成满足特定路径约束的输入。

### Seed 定义

一个 seed 是一个独立的测试用例，包含：

```go
// internal/seed/seed.go
type Seed struct {
	ID        uint64      // 唯一标识符
	Content   string      // C 源代码
	TestCases []TestCase  // 多个测试用例
	Meta      SeedMetadata
}

type SeedMetadata struct {
	FilePath   string    // Seed 目录路径
	ParentID   uint64    // 父种子 ID（初始种子为 0）
	Depth      int       // 迭代深度
	State      string    // 种子状态
}
```

### 算法流程图

```
+------------------------------------------------------------------+
|  1. 维护 mapping: 代码行 -> 首次覆盖它的种子ID                   |
+------------------------------------------------------------------+
                                  |
                                  v
+------------------------------------------------------------------+
|  2. 运行初始种子，建立 mapping，持久化种子到磁盘                 |
+------------------------------------------------------------------+
                                  |
                                  v
                        +-------------------+
                        |    约束求解循环    |
                        +-------------------+
                                  |
                                  v
+------------------------------------------------------------------+
|  3. 选取目标: 后继最多的未覆盖基本块                             |
+------------------------------------------------------------------+
                                  |
                                  v
+------------------------------------------------------------------+
|  4. 构建 Prompt:                                                |
|     - 目标函数代码 (标注: 已覆盖/未覆盖/目标行)                  |
|     - Shot: 覆盖目标前驱的种子                                   |
+------------------------------------------------------------------+
                                  |
                                  v
+------------------------------------------------------------------+
|  5. LLM 变异: 根据 shot 变异以覆盖目标 BB                        |
+------------------------------------------------------------------+
                                  |
                                  v
+------------------------------------------------------------------+
|  6. 编译测试种子                                                |
+------------------------------------------------------------------+
                                  |
                    +-------------+-------------+
                    |                           |
                    v                           v
           +----------------+          +----------------+
           | 覆盖了目标 BB？ |          | 未覆盖目标 BB   |
           +----------------+          +----------------+
                    |                           |
           +--------+--------+                |
           |                 |                v
           v                 v        +----------------+
    +------------+   +------------+    | 发散分析       |
    | 更新       |   | 塞入       |    | (uftrace)     |
    | Mapping    |   | Oracle     |    +----------------+
    +------------+   +------------+          |
           |                 |                |
           +--------+--------+                |
                    |                         |
                    v                         v
           +------------------+    +----------------------+
           | 无新覆盖率增加？ |    | 发给 LLM 进行        |
           | -> 跳过持久化   |    | 精细化变异           |
           | 有新覆盖率      |    +----------------------+
           | -> 持久化       |              |
           +------------------+              |
                    |                         |
                    +-----------+-------------+
                                |
                                v
                    +-----------------------+
                    | 返回步骤 6            |
                    +-----------------------+
```

### 模糊测试算法（约束求解循环）

针对每个防御策略和 ISA：

```
1. 维护 mapping：代码行 -> 首次覆盖它的种子 ID

2. 运行初始种子，建立 mapping，将种子持久化到磁盘

3. 约束求解循环：
   a. 选择目标：后继最多的未覆盖基本块（CFG 引导）
   b. 构建 prompt：
      - 目标函数代码（标注：已覆盖/未覆盖/目标行）
      - Shot：覆盖目标前驱的种子
   c. 发送给 LLM：根据 shot 变异以覆盖目标 BB
   d. 编译并测试变异后的种子

   IF 变异种子覆盖了目标 BB：
      - 更新 mapping
      - 塞入 Oracle
      - 无新覆盖率增加 -> 跳过持久化
      - 有新覆盖率增加 -> 持久化
      - 返回步骤 3a
   ELSE：
      - 运行发散分析（uftrace）查找 call trace 差异
      - 将发散信息发送给 LLM 进行精细化变异
      - 返回步骤 3d
```

### 测试预言机（插件化）

预言机采用插件化设计。优先使用手写的传统预言机，LLM 作为回退方案。

#### 传统预言机（Canary 示例）

对于 stack canary，使用二分搜索预言机检测绕过：

```
用缓冲区大小 N 运行（填充 'A' = 0x41）
  - 退出码 0：正常执行
  - 退出码 134 (SIGABRT)：Canary 拦截了溢出（安全）
  - 退出码 139 (SIGSEGV)：返回地址在检查前被修改（漏洞！）

在 [0, MaxBufferSize] 范围内二分搜索最小崩溃大小：
  - 最小崩溃退出码为 139 -> 检测到 Canary 绕过
  - 最小崩溃退出码为 134 -> Canary 正常工作
```

#### LLM 预言机（回退）

当没有传统预言机时，使用基于 LLM 的分析：

```
运行种子 -> 获取反馈（退出码 + stdout + stderr）-> LLM 判断是否存在漏洞
```

**注意：** 所有编译和执行直接在主机上进行。请确保系统中已安装所需的工具链（GCC、QEMU 等）并在 PATH 中可用。
