# DeFuzz

一个基于 LLM 约束求解的编译器防御策略模糊测试工具。

使用 Golang 编写。

## 核心思想

DeFuzz 灵感来自 HLPFuzz 论文。它使用 **LLM 驱动的渐进式约束求解** 来系统地探索编译器防御实现中难以触达的代码路径。

### 核心概念：基于 LLM 的约束求解

与传统覆盖率引导的模糊测试（随机变异）不同，DeFuzz 主动选择目标并引导 LLM 生成满足特定路径约束的输入。

### Seed 定义

一个 seed 是一个独立的测试用例，包含：

```go
// internal/seed/seed.go
type Seed struct {
	ID        uint64      // 唯一标识符
	Content   string      // C 源代码
	TestCases []TestCase  // 多个测试用例
	Meta      SeedMetadata
}

type SeedMetadata struct {
	FilePath   string    // Seed 目录路径
	ParentID   uint64    // 父种子 ID（初始种子为 0）
	Depth      int       // 迭代深度
	State      string    // 种子状态
}
```

### 算法流程图

```
      ┌──────────────────────────────────────────────────────────────────┐
      │       1. 维护 mapping: 每行代码 → 首次覆盖它的种子ID                  │
      └──────────────────────────────────────────────────────────────────┘
                                       ↓
      ┌──────────────────────────────────────────────────────────────────┐
      │       2. 运行初始种子，建立 mapping，持久化种子到磁盘                  │
      └──────────────────────────────────────────────────────────────────┘
                                       ↓
                               ┌───────────────┐
                               │  约束求解循环   │
                               └───────────────┘
                                       ↓
      ┌──────────────────────────────────────────────────────────────────┐
      │       3. 选取策略: 未覆盖代码中，后继最多的基本块作为目标                │
      └──────────────────────────────────────────────────────────────────┘
                                       ↓
      ┌──────────────────────────────────────────────────────────────────┐
      │  4. 构建 Prompt:                                                 │
      │     - 目标函数代码 (标注: 已覆盖行/未覆盖行/目标基本块行)               │
      │     - 目标基本块前驱对应的种子作为 shot (示例)                        │
      └──────────────────────────────────────────────────────────────────┘
                                       ↓
      ┌──────────────────────────────────────────────────────────────────┐
      │  5. LLM 变异: 根据 shot 变异出种子，期望覆盖目标基本块                 │
      └──────────────────────────────────────────────────────────────────┘
                                       ↓
      ┌──────────────────────────────────────────────────────────────────┐
      │  6. 编译测试种子                                                   │
      └──────────────────────────────────────────────────────────────────┘
                                       ↓
                       ┌───────────────┴───────────────┐
                       ↓                               ↓
             ┌───────────────────┐           ┌───────────────────┐
             │  覆盖了目标基本块?   │           │  未覆盖目标基本块   │
             └───────────────────┘           └───────────────────┘
                       ↓                               ↓
             ┌───────────────────┐           ┌───────────────────┐
             │  维护 mapping     │           │ 发散分析 (uftrace)  │
             │  塞入 Oracle      │           │ 定位 call trace    │
             │  返回步骤 3        │           │ 差异点函数          │
             └───────────────────┘           └───────────────────┘
                                                       ↓
                                           ┌───────────────────────┐
                                           │ 将发散信息发给 LLM      │
                                           │ 再次变异 (返回步骤 6)    │
                                           └───────────────────────┘
```

### 算法概述

DeFuzz 实现以下约束求解过程：

1. **维护 Mapping**: 追踪每个代码行首次由哪个种子覆盖。

2. **初始化**: 运行初始种子建立 mapping，然后将种子持久化到磁盘。

3. **目标选择**: 每次循环选取后继最多的未覆盖基本块作为目标（CFG 引导）。

4. **构建 Prompt**:
   - 提供目标函数代码，标注已覆盖/未覆盖/目标行
   - 包含覆盖目标前驱的种子作为 shot（示例）

5. **LLM 变异**: 将 prompt 发送给 LLM，要求其根据 shot 变异以覆盖目标 BB。

6. **编译测试**: 编译变异后的种子并测试是否能覆盖目标。

7. **覆盖率检查**:
   - 如果覆盖：更新 mapping，塞入 Oracle，仅在新覆盖率增加时才持久化
   - 如果未覆盖：运行发散分析（uftrace），将结果发送给 LLM 进行精细化变异

8. **发散分析**: 对比基准种子和变异种子的 call trace，找出它们的分叉点，然后将此信息发送回 LLM 进行下一次变异尝试。

### 测试预言机（插件化）

预言机采用插件化设计。优先使用手写的传统预言机，LLM 作为回退方案。

#### 传统预言机（Canary 示例）

对于 stack canary，使用二分搜索预言机检测绕过：

```
用缓冲区大小 N 运行（填充 'A' = 0x41）
  - 退出码 0：正常执行
  - 退出码 134 (SIGABRT)：Canary 拦截了溢出（安全）
  - 退出码 139 (SIGSEGV)：返回地址在检查前被修改（漏洞！）

在 [0, MaxBufferSize] 范围内二分搜索最小崩溃大小：
  - 最小崩溃退出码为 139 -> 检测到 Canary 绕过
  - 最小崩溃退出码为 134 -> Canary 正常工作
```

#### LLM 预言机（回退）

当没有传统预言机时，使用基于 LLM 的分析：

```
运行种子 -> 获取反馈（退出码 + stdout + stderr）-> LLM 判断是否存在漏洞
```

**注意：** 所有编译和执行直接在主机上进行。请确保系统中已安装所需的工具链（GCC、QEMU 等）并在 PATH 中可用。
