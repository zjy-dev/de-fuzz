package state

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"time"
)

const (
	// MetricsFileName is the name of the fuzzing metrics file.
	MetricsFileName = "fuzz_metrics.json"
)

// FuzzMetrics holds comprehensive metrics about the fuzzing session.
type FuzzMetrics struct {
	// Timing
	StartTime      time.Time `json:"start_time"`
	LastUpdateTime time.Time `json:"last_update_time"`
	ElapsedSeconds float64   `json:"elapsed_seconds"`

	// Seed statistics
	TotalSeedsRun      int `json:"total_seeds_run"`      // Total seeds processed
	CoverageIncrSeeds  int `json:"coverage_incr_seeds"`  // Seeds that triggered coverage increase
	CompileFailedSeeds int `json:"compile_failed_seeds"` // Seeds that failed to compile
	CrashedSeeds       int `json:"crashed_seeds"`        // Seeds that caused crashes

	// Oracle statistics
	OracleChecks   int `json:"oracle_checks"`   // Total oracle checks performed
	OracleFailures int `json:"oracle_failures"` // Oracle failures (bugs found)
	OracleErrors   int `json:"oracle_errors"`   // Oracle errors (analysis errors)

	// LLM statistics
	LLMCalls       int `json:"llm_calls"`       // Total LLM calls made
	LLMErrors      int `json:"llm_errors"`      // LLM call errors
	SeedsGenerated int `json:"seeds_generated"` // New seeds generated by LLM

	// Coverage statistics
	CurrentCoverage   float64 `json:"current_coverage"`    // Current coverage percentage
	TotalCoveredLines int     `json:"total_covered_lines"` // Total covered lines
	TotalLines        int     `json:"total_lines"`         // Total lines in source

	// Target function coverage (if using target function tracking)
	TargetTotalLines   int `json:"target_total_lines,omitempty"`   // Total lines in target functions
	TargetCoveredLines int `json:"target_covered_lines,omitempty"` // Covered lines in target functions

	// Performance
	AvgSeedTimeMs  float64 `json:"avg_seed_time_ms"` // Average time per seed in ms
	SeedsPerSecond float64 `json:"seeds_per_second"` // Seeds processed per second
}

// MetricsManager handles the persistence and modification of fuzzing metrics.
type MetricsManager interface {
	// Load reads the metrics from disk.
	Load() error

	// Save writes the metrics to disk.
	Save() error

	// GetMetrics returns a copy of the current metrics.
	GetMetrics() FuzzMetrics

	// Recording methods
	RecordSeedProcessed()
	RecordCoverageIncrease()
	RecordCompileFailure()
	RecordCrash()
	RecordOracleCheck()
	RecordOracleFailure()
	RecordOracleError()
	RecordLLMCall()
	RecordLLMError()
	RecordSeedGenerated()
	UpdateCoverageStats(percentage float64, covered, total int)
	SetTargetFunctionLines(total int) // Set total lines in target functions
	UpdateTargetCoverage(covered int) // Update covered lines in target functions
	UpdateTiming()

	// Formatted output
	FormatSummary() string
	FormatOneLine() string

	// Terminal UI support
	GetUI() *TerminalUI
	SetUIEnabled(enabled bool)
	RenderUI()
}

// FileMetricsManager is a file-backed implementation of MetricsManager.
type FileMetricsManager struct {
	mu       sync.Mutex
	filePath string
	metrics  FuzzMetrics
	ui       *TerminalUI
}

// NewFileMetricsManager creates a new FileMetricsManager for the given directory.
func NewFileMetricsManager(dir string) *FileMetricsManager {
	mgr := &FileMetricsManager{
		filePath: filepath.Join(dir, MetricsFileName),
		metrics: FuzzMetrics{
			StartTime: time.Now(),
		},
		ui: NewTerminalUI(),
	}
	// Link UI to metrics
	mgr.ui.SetMetrics(&mgr.metrics)
	return mgr
}

// Load reads the metrics from disk or initializes with defaults.
func (m *FileMetricsManager) Load() error {
	m.mu.Lock()
	defer m.mu.Unlock()

	data, err := os.ReadFile(m.filePath)
	if err != nil {
		if os.IsNotExist(err) {
			// Initialize with default state
			m.metrics = FuzzMetrics{
				StartTime:      time.Now(),
				LastUpdateTime: time.Now(),
			}
			return nil
		}
		return fmt.Errorf("failed to read metrics file %s: %w", m.filePath, err)
	}

	if err := json.Unmarshal(data, &m.metrics); err != nil {
		return fmt.Errorf("failed to parse metrics file %s: %w", m.filePath, err)
	}

	return nil
}

// Save writes the metrics to disk.
func (m *FileMetricsManager) Save() error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Update timing before save
	m.updateTimingLocked()

	// Ensure directory exists
	dir := filepath.Dir(m.filePath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create metrics directory %s: %w", dir, err)
	}

	data, err := json.MarshalIndent(m.metrics, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal metrics: %w", err)
	}

	if err := os.WriteFile(m.filePath, data, 0644); err != nil {
		return fmt.Errorf("failed to write metrics file %s: %w", m.filePath, err)
	}

	return nil
}

// GetMetrics returns a copy of the current metrics.
func (m *FileMetricsManager) GetMetrics() FuzzMetrics {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Update timing
	m.updateTimingLocked()
	return m.metrics
}

// RecordSeedProcessed increments the total seeds run counter.
func (m *FileMetricsManager) RecordSeedProcessed() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.TotalSeedsRun++
}

// RecordCoverageIncrease increments the coverage increase counter.
func (m *FileMetricsManager) RecordCoverageIncrease() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.CoverageIncrSeeds++
}

// RecordCompileFailure increments the compile failure counter.
func (m *FileMetricsManager) RecordCompileFailure() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.CompileFailedSeeds++
}

// RecordCrash increments the crash counter.
func (m *FileMetricsManager) RecordCrash() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.CrashedSeeds++
}

// RecordOracleCheck increments the oracle check counter.
func (m *FileMetricsManager) RecordOracleCheck() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.OracleChecks++
}

// RecordOracleFailure increments the oracle failure (bug found) counter.
func (m *FileMetricsManager) RecordOracleFailure() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.OracleFailures++
}

// RecordOracleError increments the oracle error counter.
func (m *FileMetricsManager) RecordOracleError() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.OracleErrors++
}

// RecordLLMCall increments the LLM call counter.
func (m *FileMetricsManager) RecordLLMCall() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.LLMCalls++
}

// RecordLLMError increments the LLM error counter.
func (m *FileMetricsManager) RecordLLMError() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.LLMErrors++
}

// RecordSeedGenerated increments the seeds generated counter.
func (m *FileMetricsManager) RecordSeedGenerated() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.SeedsGenerated++
}

// UpdateCoverageStats updates the coverage statistics.
func (m *FileMetricsManager) UpdateCoverageStats(percentage float64, covered, total int) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.CurrentCoverage = percentage
	m.metrics.TotalCoveredLines = covered
	m.metrics.TotalLines = total
}

// SetTargetFunctionLines sets the total number of lines in target functions.
// This should be called once during initialization when using target function tracking.
func (m *FileMetricsManager) SetTargetFunctionLines(total int) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.TargetTotalLines = total
}

// UpdateTargetCoverage updates the covered lines count for target functions.
func (m *FileMetricsManager) UpdateTargetCoverage(covered int) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.metrics.TargetCoveredLines = covered
}

// UpdateTiming updates the elapsed time and performance metrics.
func (m *FileMetricsManager) UpdateTiming() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.updateTimingLocked()
}

// updateTimingLocked updates timing metrics (must hold lock).
func (m *FileMetricsManager) updateTimingLocked() {
	m.metrics.LastUpdateTime = time.Now()
	m.metrics.ElapsedSeconds = time.Since(m.metrics.StartTime).Seconds()

	if m.metrics.ElapsedSeconds > 0 {
		m.metrics.SeedsPerSecond = float64(m.metrics.TotalSeedsRun) / m.metrics.ElapsedSeconds
	}

	if m.metrics.TotalSeedsRun > 0 {
		m.metrics.AvgSeedTimeMs = (m.metrics.ElapsedSeconds * 1000) / float64(m.metrics.TotalSeedsRun)
	}
}

// FormatSummary returns a multi-line formatted summary of the metrics.
func (m *FileMetricsManager) FormatSummary() string {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.updateTimingLocked()

	return fmt.Sprintf(`
=========================================
           FUZZING METRICS
=========================================
Duration:           %s
Seeds Processed:    %d
Coverage Increase:  %d (%.1f%%)
Compile Failures:   %d
Crashes:            %d
-----------------------------------------
Oracle Checks:      %d
Oracle Failures:    %d (bugs found)
Oracle Errors:      %d
-----------------------------------------
LLM Calls:          %d
LLM Errors:         %d
Seeds Generated:    %d
-----------------------------------------
Coverage:           %.2f%% (%d/%d lines)
Performance:        %.2f seeds/sec
Avg Seed Time:      %.1f ms
=========================================`,
		formatDuration(m.metrics.ElapsedSeconds),
		m.metrics.TotalSeedsRun,
		m.metrics.CoverageIncrSeeds,
		safePercent(m.metrics.CoverageIncrSeeds, m.metrics.TotalSeedsRun),
		m.metrics.CompileFailedSeeds,
		m.metrics.CrashedSeeds,
		m.metrics.OracleChecks,
		m.metrics.OracleFailures,
		m.metrics.OracleErrors,
		m.metrics.LLMCalls,
		m.metrics.LLMErrors,
		m.metrics.SeedsGenerated,
		m.metrics.CurrentCoverage,
		m.metrics.TotalCoveredLines,
		m.metrics.TotalLines,
		m.metrics.SeedsPerSecond,
		m.metrics.AvgSeedTimeMs,
	)
}

// FormatOneLine returns a single-line formatted summary for progress display.
func (m *FileMetricsManager) FormatOneLine() string {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.updateTimingLocked()

	return fmt.Sprintf("[%s] seeds:%d cov_incr:%d(%.1f%%) oracle_fail:%d cov:%.2f%% %.1f/s",
		formatDuration(m.metrics.ElapsedSeconds),
		m.metrics.TotalSeedsRun,
		m.metrics.CoverageIncrSeeds,
		safePercent(m.metrics.CoverageIncrSeeds, m.metrics.TotalSeedsRun),
		m.metrics.OracleFailures,
		m.metrics.CurrentCoverage,
		m.metrics.SeedsPerSecond,
	)
}

// GetFilePath returns the path to the metrics file.
func (m *FileMetricsManager) GetFilePath() string {
	return m.filePath
}

// GetUI returns the terminal UI associated with this metrics manager.
func (m *FileMetricsManager) GetUI() *TerminalUI {
	return m.ui
}

// SetUIEnabled enables or disables the terminal UI.
func (m *FileMetricsManager) SetUIEnabled(enabled bool) {
	m.ui.SetEnabled(enabled)
}

// RenderUI renders the terminal UI with current metrics.
func (m *FileMetricsManager) RenderUI() {
	m.mu.Lock()
	m.updateTimingLocked()
	m.mu.Unlock()

	m.ui.Render()
}

// Helper functions

func formatDuration(seconds float64) string {
	d := time.Duration(seconds * float64(time.Second))
	h := int(d.Hours())
	m := int(d.Minutes()) % 60
	s := int(d.Seconds()) % 60

	if h > 0 {
		return fmt.Sprintf("%dh%02dm%02ds", h, m, s)
	}
	if m > 0 {
		return fmt.Sprintf("%dm%02ds", m, s)
	}
	return fmt.Sprintf("%ds", s)
}

func safePercent(part, total int) float64 {
	if total == 0 {
		return 0
	}
	return float64(part) / float64(total) * 100
}
