# GCC 15.2.0 AArch64 Stack Canary 间接绕过分析

## 概述

- **发现时间**: 2026-01-13
- **种子 ID**: 87
- **种子路径**: `fuzz_out/aarch64/canary/corpus/id-000087-src-000001-cov-00000-05b894c3`
- **编译器**: GCC 15.2.1 20251203 (aarch64-none-linux-gnu)
- **编译选项**: `-fstack-protector-strong -O0` (或 `-O2`)
- **触发条件**: `buf_size=64, fill_size=74`
- **实际行为**: SIGSEGV (exit 139)
- **预期行为**: SIGABRT (exit 134) - canary 检测到溢出

## 触发 Bug 的种子源码

```c
/**
 * Canary Oracle Function Template - Flexible Version
 *
 * This template is used for testing stack canary protection mechanisms.
 * The LLM generates only the seed() function body.
 *
 * Usage: ./prog <buf_size> <fill_size>
 *   - buf_size:  Size of buffer to allocate (used for VLA/alloca, ignored for fixed)
 *   - fill_size: Number of 'A' characters to write into the buffer
 *   - Example: ./prog 64 128 (allocate 64-byte buffer, write 128 bytes)
 *
 * Expected behavior:
 *   - Small fill_size: Program exits normally (return 0)
 *   - Medium fill_size (canary overwritten): SIGABRT (exit code 134)
 *   - Large fill_size (ret addr overwritten): SIGSEGV (exit code 139)
 *
 * IMPORTANT FOR AARCH64:
 *   VLA and alloca() have different stack layouts than fixed-size arrays.
 *
 * The canary oracle uses binary search on fill_size to detect vulnerabilities.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <alloca.h>

void seed(int buf_size, int fill_size) {
    // Use a variable-length array (VLA) to trigger different stack layout
    // This may affect the classification bits in stack_protect_decl_phase
    char vla_buffer[buf_size];

    // Add a small character array to potentially trigger SPCT_HAS_SMALL_CHAR_ARRAY
    char small_buffer[8];

    // Add a large character array to potentially trigger SPCT_HAS_LARGE_CHAR_ARRAY
    char large_buffer[256];

    // Fill buffers without bounds checking
    // This will overflow if fill_size > buffer sizes
    memset(vla_buffer, 'A', fill_size);
    memset(small_buffer, 'B', fill_size);
    memset(large_buffer, 'C', fill_size);

    // Prevent compiler optimization
    printf("VLA + small + large arrays: filled %d bytes\n", fill_size);
}

// Disable stack protector for main to maximize attack surface
// This ensures canary check only happens in seed() if at all
#define NO_CANARY __attribute__((no_stack_protector))

NO_CANARY int main(int argc, char *argv[]) {
  if (argc != 3) {
    fprintf(stderr, "Usage: %s <buf_size> <fill_size>\n", argv[0]);
    return 1;
  }

  int buf_size = atoi(argv[1]);
  int fill_size = atoi(argv[2]);

  if (buf_size < 0 || fill_size < 0) {
    fprintf(stderr, "Error: sizes must be non-negative\n");
    return 1;
  }

  // Call the seed function with both parameters
  seed(buf_size, fill_size);

  return 0;
}
```

## GCC AArch64 栈布局注释

来源: `gcc/gcc/config/aarch64/aarch64.cc:9770`

```c
/* AArch64 stack frames generated by this compiler look like:

	+-------------------------------+
	|                               |
	|  incoming stack arguments     |
	|                               |
	+-------------------------------+
	|                               | <-- incoming stack pointer (aligned)
	|  callee-allocated save area   |
	|  for register varargs         |
	|                               |
	+-------------------------------+
	|  local variables (1)          | <-- frame_pointer_rtx
	|                               |
	+-------------------------------+
	|  padding (1)                  |
	+-------------------------------+
	|  callee-saved registers       |
	+-------------------------------+
	|  LR'                          |
	+-------------------------------+
	|  FP'                          |
	+-------------------------------+ <-- hard_frame_pointer_rtx (aligned)
	|  SVE vector registers         |
	+-------------------------------+
	|  SVE predicate registers      |
	+-------------------------------+
	|  local variables (2)          |
	+-------------------------------+
	|  padding (2)                  |
	+-------------------------------+
	|  dynamic allocation           |
	+-------------------------------+
	|  padding                      |
	+-------------------------------+
	|  outgoing stack arguments     | <-- arg_pointer
        |                               |
	+-------------------------------+
	|                               | <-- stack_pointer_rtx (aligned)

   The regions marked (1) and (2) are mutually exclusive.  (2) is used
   when aarch64_save_regs_above_locals_p is true.

   Dynamic stack allocations via alloca() decrease stack_pointer_rtx
   but leave frame_pointer_rtx and hard_frame_pointer_rtx
   unchanged.
*/
```

**关键函数** (`aarch64.cc:7997`):

```c
aarch64_save_regs_above_locals_p ()
{
  /* When using stack smash protection, make sure that the canary slot
     comes between the locals and the saved registers.  Otherwise,
     it would be possible for a carefully sized smash attack to change
     the saved registers (particularly LR and FP) without reaching the
     canary.  */
  return crtl->stack_protect_guard;
}
```

启用 `-fstack-protector-*` 时，使用布局 (2)：saved registers 在 local variables 之上。

## Bug 分析

### 实际栈布局 (-O2, buf_size=64)

通过汇编分析得出的实际栈布局：

```
High Address
  +------------------+
  | LR               | FP + 8
  +------------------+
  | FP               | FP + 0
  +------------------+ <-- FP (x29)
  | canary           | FP - 8
  +------------------+
  | small[8]         | FP - 16
  +------------------+
  | fill_size 副本   | FP - 24   <-- 被 VLA 溢出覆盖!
  +------------------+
  | (padding)        | FP - 32   <-- VLA 结束位置
  +------------------+
  |                  |
  |  VLA [64 bytes]  | FP - 96 到 FP - 33
  |                  |
  +------------------+ <-- SP (VLA 开始位置)
Low Address
```

**关键问题**: VLA 结束位置 (FP-32) 与 `fill_size` 副本 (FP-24) 之间只有 **8 字节**！

### 攻击路径

1. **VLA 溢出**: `memset(vla_buffer, 'A', 74)` - VLA 64 字节，溢出 10 字节
2. **参数破坏**: 溢出覆盖 `fill_size` 副本：`74 → 16705 (0x4141)`
3. **放大溢出**: `memset(small_buffer, 'B', 16705)` - 使用被破坏的值
4. **绕过检测**: 巨大溢出导致 SIGSEGV，canary check 代码无机会执行

### 为什么参数要存到栈上？

AArch64 调用约定：
- `x0-x7`: 参数寄存器 (**caller-saved**, 调用后被破坏)
- `x19-x28`: callee-saved (调用后保留)

`fill_size` 通过 `w1` (x1 低 32 位) 传入。调用 `memset()` 后，x1 会被破坏，但后续还需要使用 `fill_size`。

编译器的两种保存策略：
- **-O1**: 使用 `x19` (callee-saved 寄存器) → **安全**
- **-O0/-O2**: 存到栈上 → **危险，在 VLA 溢出路径上**

### 不同优化级别的测试结果

| 优化级别 | fill_size 存储位置 | 结果 |
|---------|-------------------|------|
| -O0 | 栈 [FP-40] | **139 (SIGSEGV)** - Bug |
| -O1 | x19 寄存器 | 134 (SIGABRT) - Canary 正常 |
| -O2 | 栈 [FP-24] | **139 (SIGSEGV)** - Bug |

### 验证实验

```bash
# 测试 fill_size 是否被 VLA 溢出破坏
$ qemu-aarch64 -L $SYSROOT ./test 64 74

Original fill_size: 74
After VLA memset:
  fill_size now: 16705 (0x4141)
  *** fill_size was CORRUPTED! ***
```

## 与 CVE-2023-4039 的区别

| 特征 | CVE-2023-4039 | 本次发现 |
|------|---------------|---------|
| **机制** | Canary 放置位置错误，LR 在 canary 之下 | Canary 位置正确，但 VLA 溢出可破坏 spill area |
| **直接原因** | 栈布局设计缺陷 | 寄存器分配策略 + padding 不足 |
| **绕过方式** | 直接溢出到 LR | 间接：小溢出 → 参数损坏 → 大溢出 → 崩溃 |
| **影响范围** | 所有优化级别 | 主要影响 -O0 和 -O2 |

## 结论

### Bug 定性

这是一个 **security hardening 层面的缺陷**，而非传统 bug：

1. **从安全角度**: VLA 溢出可破坏寄存器溢出区 (register spill area)，导致间接绕过 canary
2. **从 GCC 角度**: 栈布局符合文档描述，用户代码存在 UB

### 根本原因

1. `-O0/-O2` 选择将跨调用变量存到栈上而非 callee-saved 寄存器
2. VLA 与 spill area 之间的 padding 只有 8 字节
3. 小的 VLA 溢出可以被放大成灾难性溢出

### 建议

如向 GCC 报告，可建议：

1. 在有 VLA/alloca 的函数中，优先使用 callee-saved 寄存器保存跨调用变量
2. 增加 dynamic allocation 区域与 local variables 之间的 guard padding
3. 或将 spill area 放在 canary 保护的区域内

## 复现步骤

```bash
# 编译
GCC=target_compilers/gcc-v15.2.0-aarch64-cross-compile/install-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc
SYSROOT=target_compilers/gcc-v15.2.0-aarch64-cross-compile/install-aarch64-none-linux-gnu/aarch64-none-linux-gnu/libc

$GCC -fstack-protector-strong -O0 --sysroot=$SYSROOT -o test source.c

# 运行 (需要 QEMU)
qemu-aarch64 -L $SYSROOT ./test 64 74
# 预期: SIGABRT (134)
# 实际: SIGSEGV (139)
```
