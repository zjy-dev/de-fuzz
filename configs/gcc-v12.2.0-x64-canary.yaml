compiler:
  path: "/root/project/de-fuzz/gcc-v12.2.0-x64/gcc-build/gcc/xgcc"
  
  # execute gcovr in the path below, json files will be generated here
  gcovr_exec_path: "/root/project/de-fuzz/gcc-v12.2.0-x64/gcc-build"

  source_parent_path: "/root/project/de-fuzz/gcc-v12.2.0-x64"

  # gcovr command template (without --json output path)
  gcovr_command: 'gcovr --exclude ".*\.(h|hpp|hxx)$" --gcov-executable "gcov-14 --demangled-names" -r ..'

  # Compiler flags (CFlags)
  # These flags are passed to GCC during compilation
  cflags:
    - "-fstack-protector-strong"  # Enable stack canary protection
    - "-O0"                         # No optimization for better debugging

  # path to the total accumulated coverage report (optional)
  # If empty, defaults to {fuzz_output}/state/total.json for resume capability
  # This file stores accumulated coverage and is critical for checkpoint/resume
  # total_report_path: "/root/project/de-fuzz/gcc-v12.2.0-x64/gcc-build/workspace/reports/total.json"

  # Fuzzing configuration (can be overridden by command line flags)
  fuzz:
    # Root output directory for fuzzing artifacts
    # Actual output will be at {output_root_dir}/{isa}/{strategy}
    output_root_dir: "fuzz_out"
    # Maximum number of fuzzing iterations (0 = unlimited)
    max_iterations: 0
    # Maximum new seeds to generate per interesting seed
    max_new_seeds: 1
    # Maximum number of test cases to generate per seed (0 = no test cases)
    # For canary oracle, test cases are not needed - the oracle analyzes binary behavior directly
    max_test_cases: 0
    # Function template for code generation (optional)
    # If provided, LLM generates only the function body which is merged with this template
    function_template: "initial_seeds/x64/canary/function_template.c"
    # Execution timeout in seconds
    timeout: 30
    # Use QEMU for execution (for cross-architecture)
    use_qemu: false
    # Path to QEMU user-mode executable
    qemu_path: ""
    # Sysroot path for QEMU (-L argument)
    qemu_sysroot: ""
    # CFG dump file path for target function analysis
    cfg_file_path: "/root/project/de-fuzz/gcc-v12.2.0-x64/gcc-build/gcc/cfgexpand.cc.015t.cfg"
    # Maximum number of divergence analysis retries per target BB
    max_constraint_retries: 3
    # Weight decay factor for uncovered BBs per iteration (0, 1], default 0.8
    weight_decay_factor: 0.8

  # Oracle configuration
  oracle:
    # Type of oracle to use: "llm", "crash", "diff", "canary", etc.
    type: "canary"
    # Options specific to the chosen oracle
    options:
      # Maximum buffer size to test during binary search
      max_buffer_size: 1024

# Configuration pattern: Map each file to its target functions
# This allows fine-grained control over which functions to track per file
#
# Stack Canary (Stack Protector) related core functions for x86_64
# These functions are involved in:
#   1. Deciding which functions need stack protection
#   2. Classifying variable types for protection
#   3. Generating prologue (set canary) and epilogue (check canary)
#   4. Target-specific guard value handling

targets:
  # cfgexpand.cc - 栈保护核心逻辑（变量分类、冲突分析、prologue生成）
  - file: "gcc-releases-gcc-12.2.0/gcc/cfgexpand.cc"
    functions:
      # 分类变量类型，决定是否需要保护（检测字符数组、聚合类型等）
      - "stack_protect_classify_type"
      # 决定变量的保护阶段（phase 1/2）
      - "stack_protect_decl_phase"
      - "stack_protect_decl_phase_1"
      - "stack_protect_decl_phase_2"
      # 添加栈变量之间的保护冲突约束
      - "add_stack_protection_conflicts"
      # 创建栈上的 guard 变量
      - "create_stack_guard"
      # 生成函数入口的 stack canary 设置代码
      - "stack_protect_prologue"
      # 检查是否有使用返回槽的调用（-fstack-protector-strong 用）
      - "stack_protect_return_slot_p"
