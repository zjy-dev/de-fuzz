[Fuzz] Target: x64 / canary
[Fuzz] Output directory: fuzz_out/x64/canary
[Fuzz] Using local executor
[Fuzz] Coverage report path: fuzz_out/x64/canary/state/total.json
[Fuzz] Starting fresh fuzzing session...
[Fuzz] Corpus is empty, loading initial seeds from initial_seeds/x64/canary...
[Fuzz] Loaded 1 initial seeds
[Fuzz] Starting fuzzing engine...
2025/11/26 15:03:28 [Engine] Starting fuzzing loop...
2025/11/26 15:03:28 [Engine] Corpus has 1 seeds in queue
2025/11/26 15:03:28 [Engine] Iteration 1: Processing seed ID=1
2025/11/26 15:03:28 [Engine] Compiling seed 1...
2025/11/26 15:03:28 [Engine] Executing seed 1...
2025/11/26 15:03:28 [Engine] Measuring coverage for seed 1...
2025/11/26 15:03:30 [Engine] Seed 1 increased coverage!
2025/11/26 15:03:30 [Engine] Coverage increase: First seed - initial coverage established
2025/11/26 15:03:30 [Engine] Total coverage: 79.0% (64/81 lines)
2025/11/26 15:03:30 [Engine] Generating 3 new seeds from parent 1...

================================================================================
[DEBUG] BuildMutatePrompt - Generated Prompt:
--------------------------------------------------------------------------------

[EXISTING SEED]
#include <stdio.h>
#include <string.h>
#include <unistd.h>

void vulnerable_function() {
    char buffer[64];
    char canary_guard[8];
    
    // Simulate stack canary placement
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Vulnerable gets() - no bounds checking
    gets(buffer);
    
    // Format string vulnerability - can leak stack contents
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Stack buffer overflow attempt
    if(strlen(buffer) > 64) {
        printf("Buffer overflow detected!\n");
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    vulnerable_function();
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, may leak stack contents via format string, and detects buffer overflow/canary corruption"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input"
  },
  {
    "running command": "echo '%p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks stack pointer values and potentially canary through format string"
  },
  {
    "running command": "python -c "print 'A'*80" | ./prog",
    "expected result": "Triggers buffer overflow detection and may corrupt canary"
  }
]
[/EXISTING SEED]

[COVERAGE CONTEXT]
Current Total Coverage: 79.0% (64/81 lines covered)

Coverage Increase from this seed:
First seed - initial coverage established

This is the first seed, establishing baseline coverage.
[/COVERAGE CONTEXT]

[UNCOVERED CODE PATHS]
The following shows abstracted code with uncovered paths (lines marked with full code are NOT covered yet):

### cfgexpand.cc::stack_protect_classify_type(tree_node*)
Uncovered lines: [1845 1846 1847 1848 1849 1850 1851]

```cpp
unsigned int stack_protect_classify_type(tree type) {
    switch (TREE_CODE(type)) {
    case ARRAY_TYPE: // ...
    case UNION_TYPE:
    case QUAL_UNION_TYPE:
    case RECORD_TYPE:
        ret = SPCT_HAS_AGGREGATE;
        if (TREE_CODE(t) == FIELD_DECL) ret |= stack_protect_classify_type(TREE_TYPE(t));        break;    default: // ...
    }
}
```

### cfgexpand.cc::stack_protect_decl_phase(tree_node*)
Uncovered lines: [1873 1884 1886]

```cpp
int stack_protect_decl_phase(tree decl) {
    if (bits & SPCT_HAS_SMALL_CHAR_ARRAY) has_short_buffer = true;
    if (!lookup_attribute("no_stack_protector", attribs) && (flag_stack_protect == SPCT_FLAG_ALL || flag_stack_protect == SPCT_FLAG_STRONG || (flag_stack_protect == SPCT_FLAG_EXPLICIT && lookup_attribute("stack_protect", attribs)))) // ...
    else ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;

    if (ret) // ...
}
```

### cfgexpand.cc::stack_protect_prologue()
Uncovered lines: [6178 6179 6185 6187 6188 6195 6207]

```cpp
void stack_protect_prologue(void) {
    if (targetm.have_stack_protect_combined_set() && guard_decl) {
        gcc_assert(DECL_P(guard_decl));
        y = DECL_RTL(guard_decl);
        if (rtx_insn *insn = targetm.gen_stack_protect_combined_set(x, y)) {
            emit_insn(insn);
            return;
        }
    }

    if (guard_decl) // ...
    else y = const0_rtx;
    if (targetm.have_stack_protect_set()) // ...
    emit_move_insn(x, y);
}
```


[/UNCOVERED CODE PATHS]

Based on the coverage increase above, focus your mutation on:
1. Exploring similar code paths that led to the coverage increase
2. Varying the inputs that triggered the newly covered code
3. Trying edge cases around the newly covered functionality
4. Targeting the UNCOVERED CODE PATHS shown above to increase coverage

Based on the system context, mutate the existing seed to create a new variant that is more likely to find a bug or increase coverage.
Please make focused changes that could expose different vulnerability patterns.

**Output Format (MUST follow exactly):**

Your response must be in this exact format - C source code followed by the separator and JSON test cases:

[mutated C source code here]
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "expected output or behavior"
  }
]

**IMPORTANT:** 
- Output ONLY the C source code, then the separator "// ||||| JSON_TESTCASES_START |||||", then the JSON array.
- Do NOT include any markdown code blocks, headers, or other formatting.

================================================================================

2025/11/26 15:03:58 [Engine] Failed to generate new seed: failed to decode response body: stream error: stream ID 1; INTERNAL_ERROR; received from peer

================================================================================
[DEBUG] BuildMutatePrompt - Generated Prompt:
--------------------------------------------------------------------------------

[EXISTING SEED]
#include <stdio.h>
#include <string.h>
#include <unistd.h>

void vulnerable_function() {
    char buffer[64];
    char canary_guard[8];
    
    // Simulate stack canary placement
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Vulnerable gets() - no bounds checking
    gets(buffer);
    
    // Format string vulnerability - can leak stack contents
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Stack buffer overflow attempt
    if(strlen(buffer) > 64) {
        printf("Buffer overflow detected!\n");
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    vulnerable_function();
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, may leak stack contents via format string, and detects buffer overflow/canary corruption"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input"
  },
  {
    "running command": "echo '%p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks stack pointer values and potentially canary through format string"
  },
  {
    "running command": "python -c "print 'A'*80" | ./prog",
    "expected result": "Triggers buffer overflow detection and may corrupt canary"
  }
]
[/EXISTING SEED]

[COVERAGE CONTEXT]
Current Total Coverage: 79.0% (64/81 lines covered)

Coverage Increase from this seed:
First seed - initial coverage established

This is the first seed, establishing baseline coverage.
[/COVERAGE CONTEXT]

[UNCOVERED CODE PATHS]
The following shows abstracted code with uncovered paths (lines marked with full code are NOT covered yet):

### cfgexpand.cc::stack_protect_classify_type(tree_node*)
Uncovered lines: [1845 1846 1847 1848 1849 1850 1851]

```cpp
unsigned int stack_protect_classify_type(tree type) {
    switch (TREE_CODE(type)) {
    case ARRAY_TYPE: // ...
    case UNION_TYPE:
    case QUAL_UNION_TYPE:
    case RECORD_TYPE:
        ret = SPCT_HAS_AGGREGATE;
        if (TREE_CODE(t) == FIELD_DECL) ret |= stack_protect_classify_type(TREE_TYPE(t));        break;    default: // ...
    }
}
```

### cfgexpand.cc::stack_protect_decl_phase(tree_node*)
Uncovered lines: [1873 1884 1886]

```cpp
int stack_protect_decl_phase(tree decl) {
    if (bits & SPCT_HAS_SMALL_CHAR_ARRAY) has_short_buffer = true;
    if (!lookup_attribute("no_stack_protector", attribs) && (flag_stack_protect == SPCT_FLAG_ALL || flag_stack_protect == SPCT_FLAG_STRONG || (flag_stack_protect == SPCT_FLAG_EXPLICIT && lookup_attribute("stack_protect", attribs)))) // ...
    else ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;

    if (ret) // ...
}
```

### cfgexpand.cc::stack_protect_prologue()
Uncovered lines: [6178 6179 6185 6187 6188 6195 6207]

```cpp
void stack_protect_prologue(void) {
    if (targetm.have_stack_protect_combined_set() && guard_decl) {
        gcc_assert(DECL_P(guard_decl));
        y = DECL_RTL(guard_decl);
        if (rtx_insn *insn = targetm.gen_stack_protect_combined_set(x, y)) {
            emit_insn(insn);
            return;
        }
    }

    if (guard_decl) // ...
    else y = const0_rtx;
    if (targetm.have_stack_protect_set()) // ...
    emit_move_insn(x, y);
}
```


[/UNCOVERED CODE PATHS]

Based on the coverage increase above, focus your mutation on:
1. Exploring similar code paths that led to the coverage increase
2. Varying the inputs that triggered the newly covered code
3. Trying edge cases around the newly covered functionality
4. Targeting the UNCOVERED CODE PATHS shown above to increase coverage

Based on the system context, mutate the existing seed to create a new variant that is more likely to find a bug or increase coverage.
Please make focused changes that could expose different vulnerability patterns.

**Output Format (MUST follow exactly):**

Your response must be in this exact format - C source code followed by the separator and JSON test cases:

[mutated C source code here]
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "expected output or behavior"
  }
]

**IMPORTANT:** 
- Output ONLY the C source code, then the separator "// ||||| JSON_TESTCASES_START |||||", then the JSON array.
- Do NOT include any markdown code blocks, headers, or other formatting.

================================================================================

2025/11/26 15:04:30 [Engine] Generated new seed 1 from parent 1

================================================================================
[DEBUG] BuildMutatePrompt - Generated Prompt:
--------------------------------------------------------------------------------

[EXISTING SEED]
#include <stdio.h>
#include <string.h>
#include <unistd.h>

void vulnerable_function() {
    char buffer[64];
    char canary_guard[8];
    
    // Simulate stack canary placement
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Vulnerable gets() - no bounds checking
    gets(buffer);
    
    // Format string vulnerability - can leak stack contents
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Stack buffer overflow attempt
    if(strlen(buffer) > 64) {
        printf("Buffer overflow detected!\n");
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    vulnerable_function();
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, may leak stack contents via format string, and detects buffer overflow/canary corruption"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input"
  },
  {
    "running command": "echo '%p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks stack pointer values and potentially canary through format string"
  },
  {
    "running command": "python -c "print 'A'*80" | ./prog",
    "expected result": "Triggers buffer overflow detection and may corrupt canary"
  }
]
[/EXISTING SEED]

[COVERAGE CONTEXT]
Current Total Coverage: 79.0% (64/81 lines covered)

Coverage Increase from this seed:
First seed - initial coverage established

This is the first seed, establishing baseline coverage.
[/COVERAGE CONTEXT]

[UNCOVERED CODE PATHS]
The following shows abstracted code with uncovered paths (lines marked with full code are NOT covered yet):

### cfgexpand.cc::stack_protect_classify_type(tree_node*)
Uncovered lines: [1845 1846 1847 1848 1849 1850 1851]

```cpp
unsigned int stack_protect_classify_type(tree type) {
    switch (TREE_CODE(type)) {
    case ARRAY_TYPE: // ...
    case UNION_TYPE:
    case QUAL_UNION_TYPE:
    case RECORD_TYPE:
        ret = SPCT_HAS_AGGREGATE;
        if (TREE_CODE(t) == FIELD_DECL) ret |= stack_protect_classify_type(TREE_TYPE(t));        break;    default: // ...
    }
}
```

### cfgexpand.cc::stack_protect_decl_phase(tree_node*)
Uncovered lines: [1873 1884 1886]

```cpp
int stack_protect_decl_phase(tree decl) {
    if (bits & SPCT_HAS_SMALL_CHAR_ARRAY) has_short_buffer = true;
    if (!lookup_attribute("no_stack_protector", attribs) && (flag_stack_protect == SPCT_FLAG_ALL || flag_stack_protect == SPCT_FLAG_STRONG || (flag_stack_protect == SPCT_FLAG_EXPLICIT && lookup_attribute("stack_protect", attribs)))) // ...
    else ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;

    if (ret) // ...
}
```

### cfgexpand.cc::stack_protect_prologue()
Uncovered lines: [6178 6179 6185 6187 6188 6195 6207]

```cpp
void stack_protect_prologue(void) {
    if (targetm.have_stack_protect_combined_set() && guard_decl) {
        gcc_assert(DECL_P(guard_decl));
        y = DECL_RTL(guard_decl);
        if (rtx_insn *insn = targetm.gen_stack_protect_combined_set(x, y)) {
            emit_insn(insn);
            return;
        }
    }

    if (guard_decl) // ...
    else y = const0_rtx;
    if (targetm.have_stack_protect_set()) // ...
    emit_move_insn(x, y);
}
```


[/UNCOVERED CODE PATHS]

Based on the coverage increase above, focus your mutation on:
1. Exploring similar code paths that led to the coverage increase
2. Varying the inputs that triggered the newly covered code
3. Trying edge cases around the newly covered functionality
4. Targeting the UNCOVERED CODE PATHS shown above to increase coverage

Based on the system context, mutate the existing seed to create a new variant that is more likely to find a bug or increase coverage.
Please make focused changes that could expose different vulnerability patterns.

**Output Format (MUST follow exactly):**

Your response must be in this exact format - C source code followed by the separator and JSON test cases:

[mutated C source code here]
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "expected output or behavior"
  }
]

**IMPORTANT:** 
- Output ONLY the C source code, then the separator "// ||||| JSON_TESTCASES_START |||||", then the JSON array.
- Do NOT include any markdown code blocks, headers, or other formatting.

================================================================================

2025/11/26 15:05:02 [Engine] Generated new seed 2 from parent 1
2025/11/26 15:05:02 [Engine] Iteration 2: Processing seed ID=1
2025/11/26 15:05:02 [Engine] Compiling seed 1...
2025/11/26 15:05:02 [Engine] Executing seed 1...
2025/11/26 15:05:02 [Engine] Measuring coverage for seed 1...
2025/11/26 15:05:04 [Engine] Seed 1 increased coverage!
2025/11/26 15:05:04 [Engine] Coverage increase: Covered 7 new lines across 1 functions
2025/11/26 15:05:04 [Engine] Total coverage: 87.7% (71/81 lines)
2025/11/26 15:05:04 [Engine] Generating 3 new seeds from parent 1...

================================================================================
[DEBUG] BuildMutatePrompt - Generated Prompt:
--------------------------------------------------------------------------------

[EXISTING SEED]
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

struct container {
    char data[32];
    int count;
};

void vulnerable_function() {
    char buffer[64];
    struct container c;
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Use fgets instead of gets for safer input, but with wrong size
    fgets(buffer, 128, stdin);  // Wrong size - larger than buffer
    
    // Format string vulnerability with array access
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Out-of-bounds read through struct array
    printf("Struct contents: ");
    for(int i = 0; i < 40; i++) {  // Read beyond struct bounds
        printf("%02x ", ((unsigned char*)&c)[i]);
    }
    printf("\n");
    
    // Stack buffer overflow through struct
    if(strlen(buffer) > 32) {
        memcpy(c.data, buffer, strlen(buffer));  // Potential overflow into canary
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

void helper_function(int size) {
    char local_buf[16];
    char *dynamic_buf = alloca(size);
    
    printf("Helper function - size: %d\n", size);
    
    // Potential alloca overflow affecting stack layout
    if(dynamic_buf && size > 0) {
        memset(dynamic_buf, 'B', size + 8);  // May overflow into canary region
    }
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program - Struct Variant\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    if(argc > 1) {
        int size = atoi(argv[1]);
        helper_function(size);
    }
    
    vulnerable_function();
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, leaks stack via format string and out-of-bounds struct read, may corrupt canary through struct overflow"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input, shows struct memory contents"
  },
  {
    "running command": "echo '%p %p %p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks multiple stack pointer values through format string vulnerability"
  },
  {
    "running command": "python -c "print 'A'*100" | ./prog",
    "expected result": "Triggers buffer overflow through struct copy, potentially corrupting canary"
  },
  {
    "running command": "./prog 24",
    "expected result": "Calls helper function with alloca, may overflow stack with large size"
  },
  {
    "running command": "./prog 100",
    "expected result": "Large alloca size may cause stack corruption and bypass canary checks"
  }
]
[/EXISTING SEED]

[COVERAGE CONTEXT]
Current Total Coverage: 87.7% (71/81 lines covered)

Coverage Increase from this seed:
Covered 7 new lines across 1 functions

## Coverage Increase Summary

### File: gcc-releases-gcc-12.2.0/gcc/cfgexpand.cc
- Function: `stack_protect_classify_type(tree_node*)`
- New lines covered: 7 (lines: [1845 1848 1849 1850 1846 1847 1851])
- Coverage: 21/21 lines


[/COVERAGE CONTEXT]

[UNCOVERED CODE PATHS]
The following shows abstracted code with uncovered paths (lines marked with full code are NOT covered yet):

### cfgexpand.cc::stack_protect_classify_type(tree_node*)
Uncovered lines: [1845 1846 1847 1848 1849 1850 1851]

```cpp
unsigned int stack_protect_classify_type(tree type) {
    switch (TREE_CODE(type)) {
    case ARRAY_TYPE: // ...
    case UNION_TYPE:
    case QUAL_UNION_TYPE:
    case RECORD_TYPE:
        ret = SPCT_HAS_AGGREGATE;
        if (TREE_CODE(t) == FIELD_DECL) ret |= stack_protect_classify_type(TREE_TYPE(t));        break;    default: // ...
    }
}
```

### cfgexpand.cc::stack_protect_decl_phase(tree_node*)
Uncovered lines: [1873 1884 1886]

```cpp
int stack_protect_decl_phase(tree decl) {
    if (bits & SPCT_HAS_SMALL_CHAR_ARRAY) has_short_buffer = true;
    if (!lookup_attribute("no_stack_protector", attribs) && (flag_stack_protect == SPCT_FLAG_ALL || flag_stack_protect == SPCT_FLAG_STRONG || (flag_stack_protect == SPCT_FLAG_EXPLICIT && lookup_attribute("stack_protect", attribs)))) // ...
    else ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;

    if (ret) // ...
}
```

### cfgexpand.cc::stack_protect_prologue()
Uncovered lines: [6178 6179 6185 6187 6188 6195 6207]

```cpp
void stack_protect_prologue(void) {
    if (targetm.have_stack_protect_combined_set() && guard_decl) {
        gcc_assert(DECL_P(guard_decl));
        y = DECL_RTL(guard_decl);
        if (rtx_insn *insn = targetm.gen_stack_protect_combined_set(x, y)) {
            emit_insn(insn);
            return;
        }
    }

    if (guard_decl) // ...
    else y = const0_rtx;
    if (targetm.have_stack_protect_set()) // ...
    emit_move_insn(x, y);
}
```


[/UNCOVERED CODE PATHS]

Based on the coverage increase above, focus your mutation on:
1. Exploring similar code paths that led to the coverage increase
2. Varying the inputs that triggered the newly covered code
3. Trying edge cases around the newly covered functionality
4. Targeting the UNCOVERED CODE PATHS shown above to increase coverage

Based on the system context, mutate the existing seed to create a new variant that is more likely to find a bug or increase coverage.
Please make focused changes that could expose different vulnerability patterns.

**Output Format (MUST follow exactly):**

Your response must be in this exact format - C source code followed by the separator and JSON test cases:

[mutated C source code here]
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "expected output or behavior"
  }
]

**IMPORTANT:** 
- Output ONLY the C source code, then the separator "// ||||| JSON_TESTCASES_START |||||", then the JSON array.
- Do NOT include any markdown code blocks, headers, or other formatting.

================================================================================

2025/11/26 15:05:53 [Engine] Generated new seed 3 from parent 1

================================================================================
[DEBUG] BuildMutatePrompt - Generated Prompt:
--------------------------------------------------------------------------------

[EXISTING SEED]
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

struct container {
    char data[32];
    int count;
};

void vulnerable_function() {
    char buffer[64];
    struct container c;
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Use fgets instead of gets for safer input, but with wrong size
    fgets(buffer, 128, stdin);  // Wrong size - larger than buffer
    
    // Format string vulnerability with array access
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Out-of-bounds read through struct array
    printf("Struct contents: ");
    for(int i = 0; i < 40; i++) {  // Read beyond struct bounds
        printf("%02x ", ((unsigned char*)&c)[i]);
    }
    printf("\n");
    
    // Stack buffer overflow through struct
    if(strlen(buffer) > 32) {
        memcpy(c.data, buffer, strlen(buffer));  // Potential overflow into canary
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

void helper_function(int size) {
    char local_buf[16];
    char *dynamic_buf = alloca(size);
    
    printf("Helper function - size: %d\n", size);
    
    // Potential alloca overflow affecting stack layout
    if(dynamic_buf && size > 0) {
        memset(dynamic_buf, 'B', size + 8);  // May overflow into canary region
    }
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program - Struct Variant\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    if(argc > 1) {
        int size = atoi(argv[1]);
        helper_function(size);
    }
    
    vulnerable_function();
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, leaks stack via format string and out-of-bounds struct read, may corrupt canary through struct overflow"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input, shows struct memory contents"
  },
  {
    "running command": "echo '%p %p %p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks multiple stack pointer values through format string vulnerability"
  },
  {
    "running command": "python -c "print 'A'*100" | ./prog",
    "expected result": "Triggers buffer overflow through struct copy, potentially corrupting canary"
  },
  {
    "running command": "./prog 24",
    "expected result": "Calls helper function with alloca, may overflow stack with large size"
  },
  {
    "running command": "./prog 100",
    "expected result": "Large alloca size may cause stack corruption and bypass canary checks"
  }
]
[/EXISTING SEED]

[COVERAGE CONTEXT]
Current Total Coverage: 87.7% (71/81 lines covered)

Coverage Increase from this seed:
Covered 7 new lines across 1 functions

## Coverage Increase Summary

### File: gcc-releases-gcc-12.2.0/gcc/cfgexpand.cc
- Function: `stack_protect_classify_type(tree_node*)`
- New lines covered: 7 (lines: [1845 1848 1849 1850 1846 1847 1851])
- Coverage: 21/21 lines


[/COVERAGE CONTEXT]

[UNCOVERED CODE PATHS]
The following shows abstracted code with uncovered paths (lines marked with full code are NOT covered yet):

### cfgexpand.cc::stack_protect_classify_type(tree_node*)
Uncovered lines: [1845 1846 1847 1848 1849 1850 1851]

```cpp
unsigned int stack_protect_classify_type(tree type) {
    switch (TREE_CODE(type)) {
    case ARRAY_TYPE: // ...
    case UNION_TYPE:
    case QUAL_UNION_TYPE:
    case RECORD_TYPE:
        ret = SPCT_HAS_AGGREGATE;
        if (TREE_CODE(t) == FIELD_DECL) ret |= stack_protect_classify_type(TREE_TYPE(t));        break;    default: // ...
    }
}
```

### cfgexpand.cc::stack_protect_decl_phase(tree_node*)
Uncovered lines: [1873 1884 1886]

```cpp
int stack_protect_decl_phase(tree decl) {
    if (bits & SPCT_HAS_SMALL_CHAR_ARRAY) has_short_buffer = true;
    if (!lookup_attribute("no_stack_protector", attribs) && (flag_stack_protect == SPCT_FLAG_ALL || flag_stack_protect == SPCT_FLAG_STRONG || (flag_stack_protect == SPCT_FLAG_EXPLICIT && lookup_attribute("stack_protect", attribs)))) // ...
    else ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;

    if (ret) // ...
}
```

### cfgexpand.cc::stack_protect_prologue()
Uncovered lines: [6178 6179 6185 6187 6188 6195 6207]

```cpp
void stack_protect_prologue(void) {
    if (targetm.have_stack_protect_combined_set() && guard_decl) {
        gcc_assert(DECL_P(guard_decl));
        y = DECL_RTL(guard_decl);
        if (rtx_insn *insn = targetm.gen_stack_protect_combined_set(x, y)) {
            emit_insn(insn);
            return;
        }
    }

    if (guard_decl) // ...
    else y = const0_rtx;
    if (targetm.have_stack_protect_set()) // ...
    emit_move_insn(x, y);
}
```


[/UNCOVERED CODE PATHS]

Based on the coverage increase above, focus your mutation on:
1. Exploring similar code paths that led to the coverage increase
2. Varying the inputs that triggered the newly covered code
3. Trying edge cases around the newly covered functionality
4. Targeting the UNCOVERED CODE PATHS shown above to increase coverage

Based on the system context, mutate the existing seed to create a new variant that is more likely to find a bug or increase coverage.
Please make focused changes that could expose different vulnerability patterns.

**Output Format (MUST follow exactly):**

Your response must be in this exact format - C source code followed by the separator and JSON test cases:

[mutated C source code here]
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "expected output or behavior"
  }
]

**IMPORTANT:** 
- Output ONLY the C source code, then the separator "// ||||| JSON_TESTCASES_START |||||", then the JSON array.
- Do NOT include any markdown code blocks, headers, or other formatting.

================================================================================

2025/11/26 15:06:41 [Engine] Generated new seed 4 from parent 1

================================================================================
[DEBUG] BuildMutatePrompt - Generated Prompt:
--------------------------------------------------------------------------------

[EXISTING SEED]
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

struct container {
    char data[32];
    int count;
};

void vulnerable_function() {
    char buffer[64];
    struct container c;
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Use fgets instead of gets for safer input, but with wrong size
    fgets(buffer, 128, stdin);  // Wrong size - larger than buffer
    
    // Format string vulnerability with array access
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Out-of-bounds read through struct array
    printf("Struct contents: ");
    for(int i = 0; i < 40; i++) {  // Read beyond struct bounds
        printf("%02x ", ((unsigned char*)&c)[i]);
    }
    printf("\n");
    
    // Stack buffer overflow through struct
    if(strlen(buffer) > 32) {
        memcpy(c.data, buffer, strlen(buffer));  // Potential overflow into canary
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

void helper_function(int size) {
    char local_buf[16];
    char *dynamic_buf = alloca(size);
    
    printf("Helper function - size: %d\n", size);
    
    // Potential alloca overflow affecting stack layout
    if(dynamic_buf && size > 0) {
        memset(dynamic_buf, 'B', size + 8);  // May overflow into canary region
    }
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program - Struct Variant\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    if(argc > 1) {
        int size = atoi(argv[1]);
        helper_function(size);
    }
    
    vulnerable_function();
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, leaks stack via format string and out-of-bounds struct read, may corrupt canary through struct overflow"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input, shows struct memory contents"
  },
  {
    "running command": "echo '%p %p %p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks multiple stack pointer values through format string vulnerability"
  },
  {
    "running command": "python -c "print 'A'*100" | ./prog",
    "expected result": "Triggers buffer overflow through struct copy, potentially corrupting canary"
  },
  {
    "running command": "./prog 24",
    "expected result": "Calls helper function with alloca, may overflow stack with large size"
  },
  {
    "running command": "./prog 100",
    "expected result": "Large alloca size may cause stack corruption and bypass canary checks"
  }
]
[/EXISTING SEED]

[COVERAGE CONTEXT]
Current Total Coverage: 87.7% (71/81 lines covered)

Coverage Increase from this seed:
Covered 7 new lines across 1 functions

## Coverage Increase Summary

### File: gcc-releases-gcc-12.2.0/gcc/cfgexpand.cc
- Function: `stack_protect_classify_type(tree_node*)`
- New lines covered: 7 (lines: [1845 1848 1849 1850 1846 1847 1851])
- Coverage: 21/21 lines


[/COVERAGE CONTEXT]

[UNCOVERED CODE PATHS]
The following shows abstracted code with uncovered paths (lines marked with full code are NOT covered yet):

### cfgexpand.cc::stack_protect_classify_type(tree_node*)
Uncovered lines: [1845 1846 1847 1848 1849 1850 1851]

```cpp
unsigned int stack_protect_classify_type(tree type) {
    switch (TREE_CODE(type)) {
    case ARRAY_TYPE: // ...
    case UNION_TYPE:
    case QUAL_UNION_TYPE:
    case RECORD_TYPE:
        ret = SPCT_HAS_AGGREGATE;
        if (TREE_CODE(t) == FIELD_DECL) ret |= stack_protect_classify_type(TREE_TYPE(t));        break;    default: // ...
    }
}
```

### cfgexpand.cc::stack_protect_decl_phase(tree_node*)
Uncovered lines: [1873 1884 1886]

```cpp
int stack_protect_decl_phase(tree decl) {
    if (bits & SPCT_HAS_SMALL_CHAR_ARRAY) has_short_buffer = true;
    if (!lookup_attribute("no_stack_protector", attribs) && (flag_stack_protect == SPCT_FLAG_ALL || flag_stack_protect == SPCT_FLAG_STRONG || (flag_stack_protect == SPCT_FLAG_EXPLICIT && lookup_attribute("stack_protect", attribs)))) // ...
    else ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;

    if (ret) // ...
}
```

### cfgexpand.cc::stack_protect_prologue()
Uncovered lines: [6178 6179 6185 6187 6188 6195 6207]

```cpp
void stack_protect_prologue(void) {
    if (targetm.have_stack_protect_combined_set() && guard_decl) {
        gcc_assert(DECL_P(guard_decl));
        y = DECL_RTL(guard_decl);
        if (rtx_insn *insn = targetm.gen_stack_protect_combined_set(x, y)) {
            emit_insn(insn);
            return;
        }
    }

    if (guard_decl) // ...
    else y = const0_rtx;
    if (targetm.have_stack_protect_set()) // ...
    emit_move_insn(x, y);
}
```


[/UNCOVERED CODE PATHS]

Based on the coverage increase above, focus your mutation on:
1. Exploring similar code paths that led to the coverage increase
2. Varying the inputs that triggered the newly covered code
3. Trying edge cases around the newly covered functionality
4. Targeting the UNCOVERED CODE PATHS shown above to increase coverage

Based on the system context, mutate the existing seed to create a new variant that is more likely to find a bug or increase coverage.
Please make focused changes that could expose different vulnerability patterns.

**Output Format (MUST follow exactly):**

Your response must be in this exact format - C source code followed by the separator and JSON test cases:

[mutated C source code here]
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "expected output or behavior"
  }
]

**IMPORTANT:** 
- Output ONLY the C source code, then the separator "// ||||| JSON_TESTCASES_START |||||", then the JSON array.
- Do NOT include any markdown code blocks, headers, or other formatting.

================================================================================

2025/11/26 15:07:28 [Engine] Generated new seed 5 from parent 1
2025/11/26 15:07:28 [Engine] Iteration 3: Processing seed ID=2
2025/11/26 15:07:28 [Engine] Compiling seed 2...
2025/11/26 15:07:29 [Engine] Executing seed 2...
2025/11/26 15:07:29 [Engine] Measuring coverage for seed 2...
2025/11/26 15:07:30 [Engine] Iteration 4: Processing seed ID=3
2025/11/26 15:07:30 [Engine] Compiling seed 3...
2025/11/26 15:07:30 [Engine] Executing seed 3...
2025/11/26 15:07:30 [Engine] Measuring coverage for seed 3...
2025/11/26 15:07:31 [Engine] Iteration 5: Processing seed ID=4
2025/11/26 15:07:31 [Engine] Compiling seed 4...
2025/11/26 15:07:31 [Engine] Executing seed 4...
2025/11/26 15:07:31 [Engine] Measuring coverage for seed 4...
2025/11/26 15:07:31 [Engine] Seed 4 increased coverage!
2025/11/26 15:07:31 [Engine] Coverage increase: Covered 1 new lines across 1 functions
2025/11/26 15:07:32 [Engine] Total coverage: 88.9% (72/81 lines)
2025/11/26 15:07:32 [Engine] Generating 3 new seeds from parent 4...

================================================================================
[DEBUG] BuildMutatePrompt - Generated Prompt:
--------------------------------------------------------------------------------

[EXISTING SEED]
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

struct container {
    char data[32];
    int count;
};

union mixed_data {
    char chars[16];
    int numbers[4];
    long long big_num;
};

struct nested_struct {
    struct container c;
    union mixed_data u;
    char small_buf[8];
};

void vulnerable_function() {
    char buffer[64];
    struct container c;
    struct nested_struct ns;
    union mixed_data ud;
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Use fgets with wrong size - larger than buffer
    fgets(buffer, 128, stdin);
    
    // Format string vulnerability with array access
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Out-of-bounds read through struct array - now reading through nested struct
    printf("Nested struct contents: ");
    for(int i = 0; i < 60; i++) {  // Read beyond nested struct bounds
        printf("%02x ", ((unsigned char*)&ns)[i]);
    }
    printf("\n");
    
    // Access union fields to trigger different type classification
    ud.big_num = 0x1122334455667788;
    memcpy(ud.chars, buffer, 16);
    
    // Stack buffer overflow through nested struct
    if(strlen(buffer) > 32) {
        memcpy(ns.c.data, buffer, strlen(buffer));  // Potential overflow into canary
    }
    
    // Copy to small buffer in nested struct
    if(strlen(buffer) >= 8) {
        memcpy(ns.small_buf, buffer, 8);  // Small char array copy
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

void helper_function(int size) {
    char local_buf[16];
    char *dynamic_buf = alloca(size);
    
    printf("Helper function - size: %d\n", size);
    
    // Potential alloca overflow affecting stack layout
    if(dynamic_buf && size > 0) {
        memset(dynamic_buf, 'B', size + 8);  // May overflow into canary region
    }
}

void test_union_function() {
    union mixed_data local_union;
    char small_array[4];  // Small char array that might trigger different protection
    
    printf("Union test function\n");
    
    // Initialize union with different types
    local_union.big_num = 0xDEADBEEFCAFEBABE;
    memcpy(local_union.chars, "TEST", 5);
    
    // Copy to small array
    memcpy(small_array, local_union.chars, 4);
    
    // Print union contents
    printf("Union as chars: ");
    for(int i = 0; i < 16; i++) {
        printf("%c", local_union.chars[i]);
    }
    printf("\n");
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program - Nested Struct/Union Variant\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    if(argc > 1) {
        int size = atoi(argv[1]);
        helper_function(size);
    }
    
    if(argc > 2) {
        test_union_function();
    }
    
    vulnerable_function();
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, leaks nested struct memory via format string and out-of-bounds reads, tests union type handling"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input, shows nested struct and union memory contents"
  },
  {
    "running command": "echo '%p %p %p %p %p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks multiple stack pointer values through format string vulnerability, including union data"
  },
  {
    "running command": "python -c "print 'A'*100" | ./prog",
    "expected result": "Triggers buffer overflow through nested struct copy, potentially corrupting canary"
  },
  {
    "running command": "./prog 24",
    "expected result": "Calls helper function with alloca, may overflow stack with medium size"
  },
  {
    "running command": "./prog 100 1",
    "expected result": "Large alloca size plus union test function, may cause complex stack corruption patterns"
  },
  {
    "running command": "echo 'TESTINGUNION' | ./prog 0 1",
    "expected result": "Tests union functionality with input, explores type classification edge cases"
  },
  {
    "running command": "python -c "print '%08x.'*20" | ./prog",
    "expected result": "Extended format string attack to leak more stack data including union and nested struct contents"
  }
]
[/EXISTING SEED]

[COVERAGE CONTEXT]
Current Total Coverage: 88.9% (72/81 lines covered)

Coverage Increase from this seed:
Covered 1 new lines across 1 functions

## Coverage Increase Summary

### File: gcc-releases-gcc-12.2.0/gcc/cfgexpand.cc
- Function: `stack_protect_decl_phase(tree_node*)`
- New lines covered: 1 (lines: [1873])
- Coverage: 11/13 lines


[/COVERAGE CONTEXT]

[UNCOVERED CODE PATHS]
The following shows abstracted code with uncovered paths (lines marked with full code are NOT covered yet):

### cfgexpand.cc::stack_protect_decl_phase(tree_node*)
Uncovered lines: [1873 1884 1886]

```cpp
int stack_protect_decl_phase(tree decl) {
    if (bits & SPCT_HAS_SMALL_CHAR_ARRAY) has_short_buffer = true;
    if (!lookup_attribute("no_stack_protector", attribs) && (flag_stack_protect == SPCT_FLAG_ALL || flag_stack_protect == SPCT_FLAG_STRONG || (flag_stack_protect == SPCT_FLAG_EXPLICIT && lookup_attribute("stack_protect", attribs)))) // ...
    else ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;

    if (ret) // ...
}
```

### cfgexpand.cc::stack_protect_prologue()
Uncovered lines: [6178 6179 6185 6187 6188 6195 6207]

```cpp
void stack_protect_prologue(void) {
    if (targetm.have_stack_protect_combined_set() && guard_decl) {
        gcc_assert(DECL_P(guard_decl));
        y = DECL_RTL(guard_decl);
        if (rtx_insn *insn = targetm.gen_stack_protect_combined_set(x, y)) {
            emit_insn(insn);
            return;
        }
    }

    if (guard_decl) // ...
    else y = const0_rtx;
    if (targetm.have_stack_protect_set()) // ...
    emit_move_insn(x, y);
}
```


[/UNCOVERED CODE PATHS]

Based on the coverage increase above, focus your mutation on:
1. Exploring similar code paths that led to the coverage increase
2. Varying the inputs that triggered the newly covered code
3. Trying edge cases around the newly covered functionality
4. Targeting the UNCOVERED CODE PATHS shown above to increase coverage

Based on the system context, mutate the existing seed to create a new variant that is more likely to find a bug or increase coverage.
Please make focused changes that could expose different vulnerability patterns.

**Output Format (MUST follow exactly):**

Your response must be in this exact format - C source code followed by the separator and JSON test cases:

[mutated C source code here]
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "expected output or behavior"
  }
]

**IMPORTANT:** 
- Output ONLY the C source code, then the separator "// ||||| JSON_TESTCASES_START |||||", then the JSON array.
- Do NOT include any markdown code blocks, headers, or other formatting.

================================================================================

2025/11/26 15:08:42 [Engine] Generated new seed 6 from parent 4

================================================================================
[DEBUG] BuildMutatePrompt - Generated Prompt:
--------------------------------------------------------------------------------

[EXISTING SEED]
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

struct container {
    char data[32];
    int count;
};

union mixed_data {
    char chars[16];
    int numbers[4];
    long long big_num;
};

struct nested_struct {
    struct container c;
    union mixed_data u;
    char small_buf[8];
};

void vulnerable_function() {
    char buffer[64];
    struct container c;
    struct nested_struct ns;
    union mixed_data ud;
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Use fgets with wrong size - larger than buffer
    fgets(buffer, 128, stdin);
    
    // Format string vulnerability with array access
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Out-of-bounds read through struct array - now reading through nested struct
    printf("Nested struct contents: ");
    for(int i = 0; i < 60; i++) {  // Read beyond nested struct bounds
        printf("%02x ", ((unsigned char*)&ns)[i]);
    }
    printf("\n");
    
    // Access union fields to trigger different type classification
    ud.big_num = 0x1122334455667788;
    memcpy(ud.chars, buffer, 16);
    
    // Stack buffer overflow through nested struct
    if(strlen(buffer) > 32) {
        memcpy(ns.c.data, buffer, strlen(buffer));  // Potential overflow into canary
    }
    
    // Copy to small buffer in nested struct
    if(strlen(buffer) >= 8) {
        memcpy(ns.small_buf, buffer, 8);  // Small char array copy
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

void helper_function(int size) {
    char local_buf[16];
    char *dynamic_buf = alloca(size);
    
    printf("Helper function - size: %d\n", size);
    
    // Potential alloca overflow affecting stack layout
    if(dynamic_buf && size > 0) {
        memset(dynamic_buf, 'B', size + 8);  // May overflow into canary region
    }
}

void test_union_function() {
    union mixed_data local_union;
    char small_array[4];  // Small char array that might trigger different protection
    
    printf("Union test function\n");
    
    // Initialize union with different types
    local_union.big_num = 0xDEADBEEFCAFEBABE;
    memcpy(local_union.chars, "TEST", 5);
    
    // Copy to small array
    memcpy(small_array, local_union.chars, 4);
    
    // Print union contents
    printf("Union as chars: ");
    for(int i = 0; i < 16; i++) {
        printf("%c", local_union.chars[i]);
    }
    printf("\n");
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program - Nested Struct/Union Variant\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    if(argc > 1) {
        int size = atoi(argv[1]);
        helper_function(size);
    }
    
    if(argc > 2) {
        test_union_function();
    }
    
    vulnerable_function();
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, leaks nested struct memory via format string and out-of-bounds reads, tests union type handling"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input, shows nested struct and union memory contents"
  },
  {
    "running command": "echo '%p %p %p %p %p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks multiple stack pointer values through format string vulnerability, including union data"
  },
  {
    "running command": "python -c "print 'A'*100" | ./prog",
    "expected result": "Triggers buffer overflow through nested struct copy, potentially corrupting canary"
  },
  {
    "running command": "./prog 24",
    "expected result": "Calls helper function with alloca, may overflow stack with medium size"
  },
  {
    "running command": "./prog 100 1",
    "expected result": "Large alloca size plus union test function, may cause complex stack corruption patterns"
  },
  {
    "running command": "echo 'TESTINGUNION' | ./prog 0 1",
    "expected result": "Tests union functionality with input, explores type classification edge cases"
  },
  {
    "running command": "python -c "print '%08x.'*20" | ./prog",
    "expected result": "Extended format string attack to leak more stack data including union and nested struct contents"
  }
]
[/EXISTING SEED]

[COVERAGE CONTEXT]
Current Total Coverage: 88.9% (72/81 lines covered)

Coverage Increase from this seed:
Covered 1 new lines across 1 functions

## Coverage Increase Summary

### File: gcc-releases-gcc-12.2.0/gcc/cfgexpand.cc
- Function: `stack_protect_decl_phase(tree_node*)`
- New lines covered: 1 (lines: [1873])
- Coverage: 11/13 lines


[/COVERAGE CONTEXT]

[UNCOVERED CODE PATHS]
The following shows abstracted code with uncovered paths (lines marked with full code are NOT covered yet):

### cfgexpand.cc::stack_protect_decl_phase(tree_node*)
Uncovered lines: [1873 1884 1886]

```cpp
int stack_protect_decl_phase(tree decl) {
    if (bits & SPCT_HAS_SMALL_CHAR_ARRAY) has_short_buffer = true;
    if (!lookup_attribute("no_stack_protector", attribs) && (flag_stack_protect == SPCT_FLAG_ALL || flag_stack_protect == SPCT_FLAG_STRONG || (flag_stack_protect == SPCT_FLAG_EXPLICIT && lookup_attribute("stack_protect", attribs)))) // ...
    else ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;

    if (ret) // ...
}
```

### cfgexpand.cc::stack_protect_prologue()
Uncovered lines: [6178 6179 6185 6187 6188 6195 6207]

```cpp
void stack_protect_prologue(void) {
    if (targetm.have_stack_protect_combined_set() && guard_decl) {
        gcc_assert(DECL_P(guard_decl));
        y = DECL_RTL(guard_decl);
        if (rtx_insn *insn = targetm.gen_stack_protect_combined_set(x, y)) {
            emit_insn(insn);
            return;
        }
    }

    if (guard_decl) // ...
    else y = const0_rtx;
    if (targetm.have_stack_protect_set()) // ...
    emit_move_insn(x, y);
}
```


[/UNCOVERED CODE PATHS]

Based on the coverage increase above, focus your mutation on:
1. Exploring similar code paths that led to the coverage increase
2. Varying the inputs that triggered the newly covered code
3. Trying edge cases around the newly covered functionality
4. Targeting the UNCOVERED CODE PATHS shown above to increase coverage

Based on the system context, mutate the existing seed to create a new variant that is more likely to find a bug or increase coverage.
Please make focused changes that could expose different vulnerability patterns.

**Output Format (MUST follow exactly):**

Your response must be in this exact format - C source code followed by the separator and JSON test cases:

[mutated C source code here]
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "expected output or behavior"
  }
]

**IMPORTANT:** 
- Output ONLY the C source code, then the separator "// ||||| JSON_TESTCASES_START |||||", then the JSON array.
- Do NOT include any markdown code blocks, headers, or other formatting.

================================================================================

2025/11/26 15:10:01 [Engine] Generated new seed 7 from parent 4

================================================================================
[DEBUG] BuildMutatePrompt - Generated Prompt:
--------------------------------------------------------------------------------

[EXISTING SEED]
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>

struct container {
    char data[32];
    int count;
};

union mixed_data {
    char chars[16];
    int numbers[4];
    long long big_num;
};

struct nested_struct {
    struct container c;
    union mixed_data u;
    char small_buf[8];
};

void vulnerable_function() {
    char buffer[64];
    struct container c;
    struct nested_struct ns;
    union mixed_data ud;
    unsigned long canary = 0x1234567890ABCDEF;
    
    printf("Enter input: ");
    fflush(stdout);
    
    // Use fgets with wrong size - larger than buffer
    fgets(buffer, 128, stdin);
    
    // Format string vulnerability with array access
    printf("You entered: ");
    printf(buffer);
    printf("\n");
    
    // Out-of-bounds read through struct array - now reading through nested struct
    printf("Nested struct contents: ");
    for(int i = 0; i < 60; i++) {  // Read beyond nested struct bounds
        printf("%02x ", ((unsigned char*)&ns)[i]);
    }
    printf("\n");
    
    // Access union fields to trigger different type classification
    ud.big_num = 0x1122334455667788;
    memcpy(ud.chars, buffer, 16);
    
    // Stack buffer overflow through nested struct
    if(strlen(buffer) > 32) {
        memcpy(ns.c.data, buffer, strlen(buffer));  // Potential overflow into canary
    }
    
    // Copy to small buffer in nested struct
    if(strlen(buffer) >= 8) {
        memcpy(ns.small_buf, buffer, 8);  // Small char array copy
    }
    
    // Canary check simulation
    if(canary != 0x1234567890ABCDEF) {
        printf("*** stack smashing detected ***\n");
        _exit(1);
    }
}

void helper_function(int size) {
    char local_buf[16];
    char *dynamic_buf = alloca(size);
    
    printf("Helper function - size: %d\n", size);
    
    // Potential alloca overflow affecting stack layout
    if(dynamic_buf && size > 0) {
        memset(dynamic_buf, 'B', size + 8);  // May overflow into canary region
    }
}

void test_union_function() {
    union mixed_data local_union;
    char small_array[4];  // Small char array that might trigger different protection
    
    printf("Union test function\n");
    
    // Initialize union with different types
    local_union.big_num = 0xDEADBEEFCAFEBABE;
    memcpy(local_union.chars, "TEST", 5);
    
    // Copy to small array
    memcpy(small_array, local_union.chars, 4);
    
    // Print union contents
    printf("Union as chars: ");
    for(int i = 0; i < 16; i++) {
        printf("%c", local_union.chars[i]);
    }
    printf("\n");
}

int main(int argc, char *argv[]) {
    printf("Stack Canary Test Program - Nested Struct/Union Variant\n");
    printf("Canary value: 0x1234567890ABCDEF\n");
    
    if(argc > 1) {
        int size = atoi(argv[1]);
        helper_function(size);
    }
    
    if(argc > 2) {
        test_union_function();
    }
    
    vulnerable_function();
    
    printf("Program completed successfully\n");
    return 0;
}
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "Program reads input, leaks nested struct memory via format string and out-of-bounds reads, tests union type handling"
  },
  {
    "running command": "echo 'AAAA' | ./prog",
    "expected result": "Normal execution with short input, shows nested struct and union memory contents"
  },
  {
    "running command": "echo '%p %p %p %p %p %p %p %p %p %p' | ./prog",
    "expected result": "Leaks multiple stack pointer values through format string vulnerability, including union data"
  },
  {
    "running command": "python -c "print 'A'*100" | ./prog",
    "expected result": "Triggers buffer overflow through nested struct copy, potentially corrupting canary"
  },
  {
    "running command": "./prog 24",
    "expected result": "Calls helper function with alloca, may overflow stack with medium size"
  },
  {
    "running command": "./prog 100 1",
    "expected result": "Large alloca size plus union test function, may cause complex stack corruption patterns"
  },
  {
    "running command": "echo 'TESTINGUNION' | ./prog 0 1",
    "expected result": "Tests union functionality with input, explores type classification edge cases"
  },
  {
    "running command": "python -c "print '%08x.'*20" | ./prog",
    "expected result": "Extended format string attack to leak more stack data including union and nested struct contents"
  }
]
[/EXISTING SEED]

[COVERAGE CONTEXT]
Current Total Coverage: 88.9% (72/81 lines covered)

Coverage Increase from this seed:
Covered 1 new lines across 1 functions

## Coverage Increase Summary

### File: gcc-releases-gcc-12.2.0/gcc/cfgexpand.cc
- Function: `stack_protect_decl_phase(tree_node*)`
- New lines covered: 1 (lines: [1873])
- Coverage: 11/13 lines


[/COVERAGE CONTEXT]

[UNCOVERED CODE PATHS]
The following shows abstracted code with uncovered paths (lines marked with full code are NOT covered yet):

### cfgexpand.cc::stack_protect_decl_phase(tree_node*)
Uncovered lines: [1873 1884 1886]

```cpp
int stack_protect_decl_phase(tree decl) {
    if (bits & SPCT_HAS_SMALL_CHAR_ARRAY) has_short_buffer = true;
    if (!lookup_attribute("no_stack_protector", attribs) && (flag_stack_protect == SPCT_FLAG_ALL || flag_stack_protect == SPCT_FLAG_STRONG || (flag_stack_protect == SPCT_FLAG_EXPLICIT && lookup_attribute("stack_protect", attribs)))) // ...
    else ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;

    if (ret) // ...
}
```

### cfgexpand.cc::stack_protect_prologue()
Uncovered lines: [6178 6179 6185 6187 6188 6195 6207]

```cpp
void stack_protect_prologue(void) {
    if (targetm.have_stack_protect_combined_set() && guard_decl) {
        gcc_assert(DECL_P(guard_decl));
        y = DECL_RTL(guard_decl);
        if (rtx_insn *insn = targetm.gen_stack_protect_combined_set(x, y)) {
            emit_insn(insn);
            return;
        }
    }

    if (guard_decl) // ...
    else y = const0_rtx;
    if (targetm.have_stack_protect_set()) // ...
    emit_move_insn(x, y);
}
```


[/UNCOVERED CODE PATHS]

Based on the coverage increase above, focus your mutation on:
1. Exploring similar code paths that led to the coverage increase
2. Varying the inputs that triggered the newly covered code
3. Trying edge cases around the newly covered functionality
4. Targeting the UNCOVERED CODE PATHS shown above to increase coverage

Based on the system context, mutate the existing seed to create a new variant that is more likely to find a bug or increase coverage.
Please make focused changes that could expose different vulnerability patterns.

**Output Format (MUST follow exactly):**

Your response must be in this exact format - C source code followed by the separator and JSON test cases:

[mutated C source code here]
// ||||| JSON_TESTCASES_START |||||
[
  {
    "running command": "./prog",
    "expected result": "expected output or behavior"
  }
]

**IMPORTANT:** 
- Output ONLY the C source code, then the separator "// ||||| JSON_TESTCASES_START |||||", then the JSON array.
- Do NOT include any markdown code blocks, headers, or other formatting.

================================================================================

2025/11/26 15:11:17 [Engine] Generated new seed 8 from parent 4
2025/11/26 15:11:17 [Engine] Reached max iterations (5), stopping
2025/11/26 15:11:17 ========================================
2025/11/26 15:11:17            FUZZING SUMMARY
2025/11/26 15:11:17 ========================================
2025/11/26 15:11:17 Duration:     7m55.58322721s
2025/11/26 15:11:17 Iterations:   5
2025/11/26 15:11:17 Bugs found:   0
2025/11/26 15:11:17 Seeds/sec:    0.01
2025/11/26 15:11:17 ========================================
